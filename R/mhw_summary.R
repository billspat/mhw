require(terra)
require(ggplot2)
require(tidyterra)
require(stringr)
require(magrittr)
require(duckdb)


#' SQL template to calculate summary of any MHW metric
#' 
#' this function to constructs the sql to calculate a summary of an existing 
#' MHW metric over space (eg. summaries for each lat/lon coordinate), with 
#' optional filtering of ensemble and for a period by year.  This inserts these
#' into a string template to generate SQL that can be executed in an MHW 
#' database connection, using duckdb SQL dialect.   
#' The column that contains the summarized metric will be named with the
#' pattern {sql_function}_{mhw_metric}  ( example avg_int_max)
#' 
#' @param mhw_table name of the table to use
#' @param mhw_metric character name of metric ( column ) in the table to summarize: mhw_dur, int_mean, etc
#' @param sqlfun = avg; character aggregate function for duckdb, for example avg, count or median, 
#'        see https://duckdb.org/docs/sql/functions/aggregates, 
#' @param start_year = 2040; integer year to start, inclusive (dates will include this start year), for example 2040
#' @param end_year = 2049 integer year to end, inclusive (dates will include up to 12/31 of the end year), for example 2049
#' @param ensemble_list_string = NA; optional character string.  If NA, then it's ignored and all ensembles are included. 
#'     if it's string that  is a list of ensembles to include in format "006,007,008"  only those with matching 
#'     ensemble will be included.  
#'     ensembles have leading zeros, are 3 digits and this must be a separated list with leading zeros
#' @param group_id=NA optional value to set as an arbitrary  'group' value for all of the rows for these results 
#'        this is useful if these results will be combined with other results and need to be identified. 
#'        for example the gorup=2040 for the decade.  The default is NULL then it's ignored and not group column is NULL.
#'        Note that this is not used for grouping in this step, this step only produces on group  
#' @returns character SQL code to run on an MHW database
#' @export
mhw_metric_summary_sql <- function(mhw_table, 
                                 mhw_metric = 'int_mean', 
                                 sql_function = 'avg', 
                                 start_year=2040, 
                                 end_year=2069,
                                 ensemble_list_string = NA,
                                 group_id = NULL) {
  
  # if the ensemble list was sent, create the fragment of SQL that will filter on that list
  #
  if (!is.na(ensemble_list_string)) {
    ensemble_filter <- paste0(" and contains('", ensemble_list_string, "', ensemble) ")
  } else {
    ensemble_filter <- ""
  }
  
  if(is.null(group_id)) { group_id <- 'NULL'}
  
  sql_template <- "SELECT 
   lat, lon, 
   group_id as 'group', 
   {sql_function}({mhw_metric}) as {sql_function}_{mhw_metric}, 
  FROM 
   {mhw_table} 
  WHERE 
    (mhw_onset/10000) >= {start_year} and ((mhw_onset - mod(mhw_onset,10000))/10000) <= {end_year} 
    {ensemble_filter}
  GROUP BY 
    lat, lon
  ORDER by 
    lat, lon;
  "
  
  sql <- glue::glue(sql_template)
  
  return(sql)
}


#' create raster of global marine heatwave summary metric per location
#' 
#' using SQL, for example generated by mhw_metric_summary_sql, creates a single
#' raster version with lat, long and metric
#' The raster will have attributes lat, lon and the name of the metric sent
#' @param mhwdb_conn database connection
#' @param mhw_sql character string of SQL that calculates summary.  
#'        SQL must output table with 3 colums (lat, lon, some_column)
#'
#' @param rotate_globe = TRUE boolean True mean rotate the global output so prime
#'    meridian is centered, False, no rotation applied, this works if 
#'    data is maped from 0 to 360 instead of -180 to 180
#' @param crs = 'EPSG:4087' optional character coordinate reference system
#' @returns single terra raster, if  
#' @export
summary_metrics_raster <- function(mhwdb_conn, 
                                   mhw_sql,
                                   mhw_value_name,
                                   rotate_globe = TRUE,
                                   crs='EPSG:4087'){
  
  summary_by_loc<- DBI::dbGetQuery(conn=mhwdb_conn, mhw_sql)
  mhw_raster <-terra::rast(summary_by_loc)
  # climate data is 0 to 360, use rotate to make -180 to 180
  if(rotate_glob){
    mhw_raster <- terra::rotate(mhw_raster)
  }
  return(mhw_raster)
}


